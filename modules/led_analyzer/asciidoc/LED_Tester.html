<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.9" />
<title>Project LED Tester</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Project LED Tester</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>Subhan Waizi<br />
&lt;<a href="mailto:swaizi@hilscher.com">swaizi@hilscher.com</a>&gt;<br /></p></div>
</div>
</div>
<div class="sect1">
<h2 id="About">About</h2>
<div class="sectionbody">
<div class="paragraph"><p>This document describes the LED Tester project which uses TCS3472 color sensors from AMS. The LED Tester tests LEDs for their dominant wavelength,
a parameter which can be found in the datasheet of the LED to be tested. General goal was to have an automated test where you provide dominant
wavelength and saturation as an input and OK or NOT OK as result.</p></div>
<div class="paragraph"><p>The hardware needed for this project consists of one or more ftdi-device(s) [ft2232h] and 16 of AMS TCS3472 color sensors per device. It is recommended to use
fibre optics to directly connect sensor and the LED under test to avoid errors invoked by external light.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="Software">Software</h2>
<div class="sectionbody">
<div class="paragraph"><p>With help of libftdi and libusb we provide an interface to talk to the ftdi-devices. During development libftdi v1.1 and libusb v1.0.18 were used to write
the software i2c needed for addressing 16 I2C sensors with same addresses. These functions were wrapped using swigtest and made ready for use under LUA. LUA itself controls the color related calculations and thus the final validation
of the LED color.</p></div>
<div class="ulist"><ul>
<li>
<p>
color_conversions.lua:
</p>
<div class="ulist"><ul>
<li>
<p>
This script implements the color conversions between different color spaces. As TCS3472 provides 4 x 16Bit values, Clear, Red, Green and Blue we need to convert to different
  color spaces in order to calculate a dominant wavelength at the end. The Conversions implemented right now are RGB-&#8594;XYZ (using sRGB) -&#8594; xyY -&#8594; Dominant Wavelength.
  For test purposes different XYZ conversion matrices were used depeneding on the source RGB space we set as our base. sRGB base seems to provide the best test results and is therefore currently used.
  The Yxy -&#8594; dominant wavelength algorithm will be introduced in the chapter <a href="#Wavelength_calculation">[Wavelength_calculation]</a>.
</p>
</li>
</ul></div>
</li>
<li>
<p>
testerboard.lua:
</p>
<div class="ulist"><ul>
<li>
<p>
This is a configuration file which will later be unique for each hardware under test. It provides a table tTest which will have entries for each ftdi-device and 16 sensor entries under each ftdi-device.
  For example tTest[1][3] means third color sensor connected to the first ftdi-device. Each sensor can have several attributes, depending on the data provided by the LED datasheet. In case of color specification datasheets either
  provide a dominant wavelength (more frequent) or a bin which is an area in the CIE Yxy graph where the LED x/y chromaticity pair can be found.
  [horizontal]
</p>
<div class="dlist"><dl>
<dt class="hdlist1">
name
</dt>
<dd>
<p>
Name of the LED under test, for example PHY0 LED
</p>
</dd>
<dt class="hdlist1">
dWavelength
</dt>
<dd>
<p>
The dominant wavelength of the LED which can be found in the datasheet. Dominant wavelength gives information about the LEDs emitted colour.
                                        Unit: nanometer (nm)
</p>
</dd>
<dt class="hdlist1">
tol_nm
</dt>
<dd>
<p>
The tolerance value which the measured wavelength can have in order to still be recognized. It is DELTA, thus wavelengths which lie in
                                        [dWavelength - tol_nm &#8230; dWavelength + tol_nm] are valid.
</p>
</dd>
<dt class="hdlist1">
sat
</dt>
<dd>
<p>
The color&#8217;s saturation. Must be measured by the program for on state and then filled in aftwards. It&#8217;s mostly around 90-100 for bright LEDs, around 40 for very
                                        LEDs, &#8230;
</p>
</dd>
<dt class="hdlist1">
tol_sat
</dt>
<dd>
<p>
tolerance the sat value can have in order for the LED to be found valid. Tolerance given in percent of the saturation value. For example a tol_sat = 5 would mean
                                        5% tolerance for the saturation value (Unlike the tol_nm value which is given in absolute difference value)
</p>
</dd>
<dt class="hdlist1">
x/y
</dt>
<dd>
<p>
If the datasheet provides a bin / xyPair instead of dominant wavelength, you can use this pair as an input. The software will then check if
                                        the x/y value provided by the sensor lies within a circle (center: x/y from datasheet) with tol_xy as its radius. If so, the LED is recognized, thus valid.
</p>
</dd>
<dt class="hdlist1">
tol_xy
</dt>
<dd>
<p>
The tolerance the xy-value of the sensor may have in order to be found valid by the software. Imagine a circle with the datasheet&#8217;s x/y pair as centerpoint and tol_xy as radius.
                                        If point given by the sensor lies within this circle area, we have a valid LED.
</p>
</dd>
<dt class="hdlist1">
LED_State
</dt>
<dd>
<p>
This gives information about the state of the LED. For now we can have 3 different values in LED, initially 0 and if the desired LED color is not recognized it will remain 0.
                                        1 if all goes well and we recognized the wavelength and saturation we are looking for. Finally 2 if we recognized the wavelength, but the saturation doesn&#8217;t lie within the tolerance range.
</p>
</dd>
</dl></div>
</li>
</ul></div>
</li>
<li>
<p>
color_validation.lua:
</p>
<div class="ulist"><ul>
<li>
<p>
This script is used to compare input dominant wavelength (found in a datasheet) and saturation with the dominant wavelength and saturation calculated with help of the sensor values.
  A configuration script testerboard.lua which contains the dominant wavelengths and saturations looked for for each sensor will be used here. Each sensor has an attribute called LED_State which is initially
  on 0, and will be put to 1 if dominant wavelength and purity are recognized, to 2 if only dominant wavelength but not the purity is recognized and will remain 0 if the wavelength looked for and current wavelength given by the sensor
  differ.
  If the test runs well and all LEDs are recognized in the end, all LED_State values must be 1.
</p>
</li>
</ul></div>
</li>
<li>
<p>
tcsChromaTable.lua:
</p>
<div class="ulist"><ul>
<li>
<p>
This script provides the data for the final wavelength calculation containing a table tTCS_chromaticity which holds the spectral responsitivity of the AMS TCS3472 light-to-digital sensor.
  TCS3472 Spectral Responsitivity.xls was used as a basis for this table. This .xls file which provided the spectral responsitivity of our sensor can be requested from AMS. It contains the spectral responsitivity in RGB / C space.
  For our purposes the RGB space was converted into XYZ and afterwards into Yxy. At last the data, which had 5nm stepsize, was interpolated using a combination of linear and spline interpolation. Current wavelength stepsize is 0.3125nm, an acceptable granulation
  for this application. All calculations resulting in this table were done in Matlab.
</p>
</li>
</ul></div>
</li>
<li>
<p>
runme.lua:
</p>
<div class="ulist"><ul>
<li>
<p>
This is the main script which calls the wrapped functions from the files listed above. It creates a table containing the device handles (Note: 2 handles per 1 ftdi-device, as each Channel gets its own handle) and tables containing Red, Green, Blue and Clear Colors.<br />
  Program flow:<br />
  Detect all devices -&#8594; iterate over all devices and -&#8594; <code>Initialize Sensors</code> -&#8594; <code>Read out colors</code> -&#8594; <code>Check Colors for validity</code> -&#8594; Convert into desired color spaces -&#8594; Validate LEDs<br />
  First we initialize the sensors by turning them on, setting gain and integration time. Reading colors will first check if sensors respond by checking their IDs and if so read out the colors. If needed we wait for the conversions to be completed and then read out the colors.
  By checking specific contents of the sensor&#8217;s registers we can find out if given datasets are valid or environment light is too bright, in which case we would need to turn down the gain. In case any of these <code>functions</code> fail we have a maximum of <code>INIT_MAXERROR</code>, <code>READ_MAXERROR</code> and <code>VALID_MAXERROR</code> retries before aborting the test.
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="Test_description">Test description</h2>
<div class="sectionbody">
<div class="paragraph"><p>For testing a specific board you have to fill in the input data of the configuration file testerboard.lua. As described in this chapter <a href="#Software">[Software]</a> you can either fill in a combination of [wavelength / saturation] or [x / y]. If both pairs are given, the program will prefer wavelength / saturation.
For high accuracy and solid wavelength detection all wavelengths under 405nm and above 660nm were cut out leaving a range of [450 &#8230; 660 nm], all wavelengths under 450 and above 660 will be set to these boundaries. Nevertheless this range is sufficient for most LEDs under test.
Two <a href="#Parameters">[Parameters]</a> gain and integration time can be set in the lua script, which are currently set to <code>gain = 4</code> and <code>integration time = 100ms</code>, proven as good values for both dark and bright LEDs. Running the runme.lua script will return either TEST_RESULT_SUCCESS or TEST_RESULT_FAILED_LED / TEST_RESULT_FAILED_SENSORS.
For best test results one should provide a constant distance between fibre optics and LED under test and additionally protect the sensor itself against disturbing environmental lighting. Following these suggestions an accuracy of +/- 2nm can be achieved.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
TEST_RESULT_SUCCESS
</dt>
<dd>
<p>
All LEDs found by our sensors are valid, the test was successful.
</p>
</dd>
<dt class="hdlist1">
TEST_RESULT_FAILED_SENSORS
</dt>
<dd>
<p>
Problems occurred with the sensors. This could be the result of invalid RGBC datasets, maximum clear level exceedings, identification problems, incomplete conversions or general problems with libusb.
</p>
</dd>
<dt class="hdlist1">
TEST_RESULT_FAILED_LED
</dt>
<dd>
<p>
One or more LEDs from the testboard couldn&#8217;t be found. In this case the LEDs which are invalid will be printed.
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="Parameters">Parameters</h2>
<div class="sectionbody">
<div class="paragraph"><p>There is the possibility of gain and integration time configuration. Dark environments require a longer integration time and / or higher gain factors. Longer integration time will slow the sensor and therefore the program down,
thus we have to make a good compromise for this parameter. Note that the LED Analyzer should be able to detect both bright LEDs and darker LEDs (for example RDY/RUN LEDs on NXHX boards), thus a range in between both integration time boundaries (2.4ms / 700ms) might be a good choice.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
gain
</dt>
<dd>
<p>
can be set to 1X, 4X, 16X and 60X
</p>
</dd>
<dt class="hdlist1">
integrationtime
</dt>
<dd>
<p>
adjustable in 2.4ms steps from 2.4ms to 700ms. Refer to sensor&#8217;s datasheet for calculation the content of the register.
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="Wavelength_calculation">Wavelength calculation</h2>
<div class="sectionbody">
<div class="paragraph"><p>As most datasheets provide dominant wavelength for color specification, a main goal of this project was to calculate a wavelength as close to LED datasheet&#8217;s wavelength as possible. The algorithm to calculate the dominant wavelength is implemented in color_conversions.lua <a href="#software">[software]</a>.
After some conversions the sensor provides a  x/y chromaticity pair which can be marked as a point on following image:</p></div>
<div class="paragraph"><div class="title">TCS3472 spectral sensitivity</div><p><span class="image">
<a class="image" href="images/spectral_line.jpg">
<img src="images/spectral_line.jpg" alt="TCS3472 spectral sensitivity" width="256" />
</a>
</span></p></div>
<div class="paragraph"><p>We calculate our direction vectors from reference white point (D65) to each wavelength x/y pair (marked as o) on the spectral line. Afterwards we calculate Whitepoint to current sensor x/y point direction vector. By calculating the smallest angle between current and table direction vector we can find out to which wavelength point on
the spectral line our current direction vector is pointing to. That is the wavelength. As we use the TCS3472 sensor we have to approach its spectral responsitivity, which was done as described in tcsChromaTable.lua under <a href="#software">[software]</a>.
If we had an ideal sensor we would have used following spectral line curve (1931 CIE Yxy):</p></div>
<div class="paragraph"><div class="title">1931 CIE Chromaticity Diagram</div><p><span class="image">
<a class="image" href="images/chroma_diag.jpg">
<img src="images/chroma_diag.jpg" alt="1931 CIE Chromaticity Diagram" width="256" />
</a>
</span></p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">As the configuration file testerboard.lua is the main source for user input, data in this table should be consistent. Especially tolerances might be hard to find out, as too big ones detect great ranges of wavelengths, too small ones might result in no LED detection at all.
An idea here is to start with a tolerance of around 5nm, perform measurements and print these out. If you see the tolerance can be decreased, just lower it, measure again and so on, until you have the smallest value possible for which the LED can still be recognized safely. Same procedure can be adapted for tol_sat and tol_xy.</td>
</tr></table>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2014-10-02 12:32:52 Mitteleuropäische Sommerzeit
</div>
</div>
</body>
</html>
